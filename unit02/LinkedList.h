#include<stdlib.h>
#include<stdio.h>
#include<ctype.h>
#include<string.h>
#include"CommonHeader.h"
#include"Node.h"

typedef struct LIST_P LIST;
typedef struct ListDataPointersP ListDataPointers;
typedef enum MOD_TYPE_P MOD_TYPE;
typedef enum FIND_BY_P FIND_BY;
LIST* newLinkedList(ListDataPointers* listDataPointers, FunctionPointers* nodeFunctionPointers);

int initList(LIST* list, FunctionPointers* functionPointers, ListDataPointers* listDataPointers);
int deleteList(LIST* list);
int saveList(LIST* list);

int newElement(LIST* list, FILE* file);
int addElement(LIST* list, NODE* node);
 
NODE* modifyElement(LIST* list, MOD_TYPE modType);

int incriment(LIST* list);

int getElementP(LIST* list, NODE* nodes[]);
int getElement(LIST* list, FIND_BY type, void* value, NODE* nodes[]);

int getIndexIn();
int findIndex(LIST* list, NODE* nodes[],  int index);
int printElement(LIST* list);

int printList(LIST* list, FIND_BY type, void* target);
int createTitleString(LIST* list, FIND_BY type, char titleString[]);

/*
  MOD_TYPE
  description
    used by the modify function. Holds a value determining whether the 
    user wishes to modify or remove an element.
  data:
    MODIFY      the user wishes to use the modify function to actually modify
                an element.
    REMOVE      the user wishes to completely remove an element.

*/
enum MOD_TYPE_P 
{ 
  MODIFY = 0 , 
  REMOVE = 1 
};

/*
  FIND_BY
  description
    this enumeration primarally applies to the getElement function.
    the values which it represents indicate by what means data is to be
    located. In the event that this value is generated by function 
    based on user input from a value function it may hold other data
    but only the following are relevent to operations from the
    linked list's perspective.
  data:
    BY_KEY      this indicates that the comparison which is
                required to find the element required is ordinal, and
                thus requires the calling of an appropriate function
                provided by the value.
    INDEX       an element is to be located by index.

    *OTHER*     other values can be held by this data-type but are processed
                by functions provided elseware.
                

*/
enum FIND_BY_P 
{ 
  BY_KEY  = 0 , 
  INDEX   = 1
};
/*
  LIST
  description
    struct containing the definition for a list (essentially an abstract structure).
  data:
    root          pointer to a root or "head" node struct 
                  (as defined in NODE).
    size          the number of elements "size" in the list.
    functionPointers   
                  a pointer to a FunctionPointers struct
                  (as defined in NODE). A reference to this
                  is passed on to all child nodes.
    listDataPointers   
                  a pointer to a listDataPointers struct.
                  This contains functions essential to LIST
                  operations and a link to a file where initial
                  data can be found.
*/
struct LIST_P
{
  NODE* root;
  int size;

  FunctionPointers* functionPointers;
  ListDataPointers* listDataPointers;
};

/*
  ListDataPointers
  description
    struct containing the function pointers and
    data neccessary to perform operations on lists.
  data:
    findMenu    menu inquiring as to how the user wishes
                to locate an element.
                  param   -void
                  return  -menu selection
    prompt      obtains input from the user for testing
                purposes.
                  param   -type of value to be obtained
                          -buffer to store input
                  return  -NULL
    tableHeader writes a table header for the "display 
                all" table.
                  param   -buffer to be filled with header
                  return -NULL

    fileAddress the addres of the file where initial data 
                can be found.
*/
struct ListDataPointersP 
{
  int (*findMenu)();
  int (*prompt)(int type, void* input);
  int (*tableHeader)(char* string);
  char* fileAddress;
};


/*
  newLinkedList
  description
    creates a new list.
  params:
    listDataPointers
              function pointers and data being 
              associated with the new list.
    functionPointers
              function pointers being 
              associated with the new node.
  return: 
    LIST*     node created 
*/
LIST* newLinkedList(ListDataPointers* listDataPointers, FunctionPointers* nodeFunctionPointers)
{

  LIST* list = (LIST*) malloc(sizeof(LIST));

  if(list == NULL)
  {
    printf("sufficient memory could not be allocated to create list");
    PAUSE
    exit(0);
  }

  initList(list, nodeFunctionPointers, listDataPointers);
  return list;
}

/*
  initList
  description
    creates a new list.
  params:
    list      newly created list to be initialized
    listDataPointers
              function pointers and data being 
              associated with the new list.
    functionPointers
              function pointers being 
              associated with the new node.
  return: 
    NULL      0 value indicating successful exicution.
*/
int initList(LIST* list, FunctionPointers* functionPointers, ListDataPointers* listDataPointers)
{
  FILE* file;
  list->root = NULL;
  list->size = 0;
  
  list->functionPointers = functionPointers;
  list->listDataPointers = listDataPointers;

  file = fopen(list->listDataPointers->fileAddress, "rb");
  while(file != NULL && !feof(file))
  {
    newElement(list, file);
  }
  if(file != NULL)
  {
    fclose(file);
  }
  return 0;
}

/*
  deleteList
  description
    frees memory assiciated with all structures 
    in a list.
  params:
    list      list to be deleted.
  return: 
    NULL      0 value indicating successful exicution.
*/
int deleteList(LIST* list)
{
  NODE* node = list->root;
  while(node != NULL)
  {
    NODE* next = node->next;

    deleteNode(node);
    node = next;
  }


  free(list);

  return 0;
}

/*
  saveList
  description
    opens the file, the address of which is provided
    in the listDataPointers struct, and uses the
    saveNode function to write all associated values
    to it in a binary format.
  params:
    list      list to be saved.
  return: 
    NULL      0 value indicating successful exicution.
*/
int saveList(LIST* list)
{
  NODE* node = list->root;
  FILE* file = fopen(list->listDataPointers->fileAddress, "wb");
  while(node != NULL)
  {
    saveNode(node, file);
    node = node->next;
  }
  fclose(file);
  return 0;
}

/*
  newElement
  description
    opens the file, the address of which is provided
    in the listDataPointers struct, and uses the
    saveNode function to write all associated values
    to it in a binary format.
  params:
    list      list to be added to.
    file      from which a new element is to be retrieved.
              When file is NULL the user is prompted for
              contact info.
  return: 
    NULL      0 value indicating successful exicution.
*/
int newElement(LIST* list, FILE* file)
{
  NODE* node = newNode(list->functionPointers, file);
  if(node != NULL)
  {
    addElement(list, node);
    return 1;
  }
  else
  {
    return 0;
  }
}

/*
  addElement
  description
    adds a new node to the list.
  params:
    list      list to be added to.
    nodeIn    node to be added to the list.
  return: 
    NULL      0 value indicating successful exicution.
*/
int addElement(LIST* list, NODE* nodeIn)
{
  //node array which will hold the inputs new parent and child
  NODE* nodes[] = {list->root, list->root};
  list->size++;

  getElement(list, BY_KEY, nodeIn, nodes);
  
  //if nodes[0] == nodes[1] then the input is the new root
  if(nodes[0] != nodes[1])
  {
    nodeIn->next = nodes[0]->next;
    nodes[0]->next = nodeIn;
  }
  else
  {
    nodeIn->next = list->root;
    list->root = nodeIn;
  }
  incriment(list);
  return 0;
  
}

/*
  modifyElement
  description
    function is used to modify or delete an element.
  params:
    list      list to be modified.
    remove    whether this opereration is to remove 
              an element or not.
  return: 
    node      the modified (or removed) node.
*/
NODE* modifyElement(LIST* list, MOD_TYPE modType)
{
  //node array which will hold the inputs desired element and its
  //parent
  NODE* nodes[2] = {list->root, list->root};
  int choice = !getElementP(list, nodes);

  if(nodes[1] != NULL && choice != 0 )
  {
    list->size--;
    if(nodes[0] == nodes[1])
    {
      list->root = nodes[1]->next;
    }
    else
    {
      nodes[0]->next = nodes[1]->next;
      
    }
    if(modType == REMOVE)
    {
      deleteNode(nodes[1]);
      nodes[1] = NULL;
    }
    else
    {
      nodes[1]->index = 0;
      nodes[1]->next = NULL;
      editNode(nodes[1]);
      addElement(list, nodes[1]);
    }
    incriment(list);
    return nodes[1];
  }
  else if(choice == 0)
  {
    printf("\nERROR: INPUT NOT FOUND\n");
    
  }
  return NULL;
}

/*
  incriment
  description
    updates the numbering on all list elements.
  params:
    list      list to be modified.
  return: 
    NULL      0 value indicating successful exicution.
*/
int incriment(LIST* list)
{
  NODE* node = list->root;
  int i;

  for(i = 1; node != NULL; i++)
  {
    node->index = i;
    node = node->next;
  }
  return 0;
}


/*
  getElementP
  description
    function is used to prompt for an element discription, and find it.
  params:
    list      list to be searched.
    nodes     the element fitting the retrieved description
              and its predicessor (or the same element twice
              if it is the root).
  return: 
    type      the type of comparison carried out
*/
int getElementP(LIST* list, NODE* nodes[])
{
  FIND_BY choice = (FIND_BY) list->listDataPointers->findMenu();

  char* input = valueBufferC;
  int ret;

  if(choice != 1 && choice != 0)
  {
    list->listDataPointers->prompt(choice, (void*) input);
  }
  else if(choice == 0)
  {
    input[0] = '\0';
    return NULL;
  }

  ret = getElement(list, choice, (void*) input, nodes);
  input[0] = '\0';
  return ret;
}

/*
  getElement
  description
    function is used to retrieve an element fitting its parameters.
  params:
    list      list to be searched.
    type      the type of comparison to be carried out.
    value     the value with which nodes are being compared
    nodes     the element fitting the retrieved description
              and its predicessor (or the same element twice
              if it is the root).
  return: 
    type
*/
int getElement(LIST* list, FIND_BY type, void* value, NODE* nodes[])
{

  if(type == INDEX)
  {

    int index = getIndexIn();
    findIndex(list, nodes, index);
	return index > list->size;
  }
  else
  {
    int compare = 1;
    while(nodes[1] != NULL && compare != 0)
    {
      if(type == BY_KEY)
      {
        compare = nodeCompareSort(nodes[1], (NODE*) value) < 0;
      }
      else
      {
        compare = nodes[1]->functionPointers->compareFind(nodes[1]->value, type, value);

      }
      if(compare == 0)
      {
        return 0;
      }
      
      nodes[0] = nodes[1];
      nodes[1] = nodes[1]->next;

    }
	
    
  }
  return 1;
}

/*
  getIndexIn
  description
    prompts for and gets the index of the desired element.
  params:
    void
  return: 
    index     the index of the desired element.
*/
int getIndexIn()
{
  int index; 
  printf("please enter the index number of the desired contact.");
  scanf("%d", &index);
  return index;
}

/*
  findIndex
  description
    locates element at the provided index.
  params:
    list      list in which the element is located.
    nodes     the array of nodes to which results are being saved.
    index     the index of the desired element.
  return: 
    NULL      0 value indicating successful exicution.
*/
int findIndex(LIST* list, NODE* nodes[],  int index)
{

  if(nodes[1] != NULL && index != 1 && list->size >= index)
  {
    int i;
    for(i = 1; i < index && (nodes[1]->next != NULL); i++)
    {
      nodes[0] = nodes[1];
      nodes[1] = nodes[1]->next;
        
    }
  }
  return 0;
}
/*
  printElement
  description
    request an element discription from the user then print
    the value's info at full size.
  params:
    list      list in which the element is located.
  return: 
    NULL      0 value indicating successful exicution.
*/
int printElement(LIST* list)
{
  char* valueString = valueBufferC;

  NODE* nodes[2] = {list->root, list->root};

  int choice = !getElementP(list, nodes);

  if(nodes[1] != NULL && choice)
  {

    getFunctions(nodes[1])->toString(getValue(nodes[1]), valueString, 1);
    printf("\n%s\n", valueString);

  }
  else if(!choice)
  {
    printf("\nERROR: INPUT NOT FOUND\n");
  }
  valueString[0] = '\0';
  return 0;
}

/*
  printList
  description
    prints formatted list in tabular form using the criteria provided.
  params:
    list      list being printed.
    type      the type of comparison being carried out.
    target    the value being searched for.
  return: 
    NULL      0 value indicating successful exicution.
*/
int printList(LIST* list, FIND_BY type, void* target)
{
  char* headString = valueBufferA;
  char* titleString = valueBufferB;

  int i;
  int ws;

  NODE* node = list->root;
  int count = 0;

  list->listDataPointers->tableHeader(headString);
  CLEAR
  
  createTitleString(list, type, titleString);

  ws = strlen(headString)/2 + 5 - strlen(titleString)/2;
  for(i = 0; i < ws; i++)
  {
    printf(" ");
  }
  printf("%s\n\n", titleString);

  printf("index     %s\n", headString);

  headString[0] = '\0';
  titleString[0] = '\0';

  while(node != NULL)
  {
    if(type == BY_KEY || !nodeCompareFind(node,type,target))
    {
      char* string = valueBufferA;
      nodeToString(node, string);
      printf("%s\n", string);
      count++;
      string[0] = '\0';
    }
    node = node->next;

  }
  printf((type == BY_KEY ? "%d record(s) fit your description.\n\n" : "you have %d contacts.\n\n"), count);
  return 0;
}

/*
  createTitleString
  description
    generates a table heading based on the name of the file from which 
    initial records have been read in.
  params:
    list      list being printed.
    type      the type of comparison being carried out.
    titleString
              the buffer to which the title is being printed
  return: 
    NULL      0 value indicating successful exicution.
*/
int createTitleString(LIST* list, FIND_BY type, char titleString[])
{
  int i = 0;
  char s[1];
  char* address = list->listDataPointers->fileAddress;
  s[0] = ' ';
  titleString[0] = '\0';
  sprintf(titleString, "%s LIST OF ", type == BY_KEY ? "COMPLETE" : "PARTIAL");
  while(address[i] != '.' && address[i] != '\0')
  {
    char c[1];
    
    c[0] = address[i++];
    if(c[0] == '_' || isupper(c[0]))
    {

		 
      strncat(titleString, s, 1);
      if(c[0] == '_') continue;

    }
    c[0] = toupper(c[0]);
    strncat(titleString, c, 1);
  }
  if(titleString[0] != '\0') titleString[0] = toupper(titleString[0]);
}